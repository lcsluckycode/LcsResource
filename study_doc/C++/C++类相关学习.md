# C++类相关学习

# 1. 基础定义

## 1. 1. 定义

![img](E:\lcsprogram\study_doc\C++\images\类定义.png)

访问类元素，使用 `.` 符号

## 1.2. 构造函数和析构函数

**构造函数**：构造函数的名称与类的名称是完全相同的，并且***不会返回任何类型***，也***不会返回 void***。构造函数可用于为某些成员变量设置初始值。可以带参数，也可以不带参数

初始化参数列表

```cpp
C::C( double a, double b, double c): X(a), Y(b), Z(c)
{
  ....
}
```

**析构函数**：是类的一种特殊函数，他会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它***不会返回任何值***，也***不能带有任何参数***。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

**拷贝构造函数**：一种特殊的构造函数，在创建对象的时候，使用同一类中之前创建的对象来初始化新创建的对象。常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象
- 复制对象作为参数传递给函数
- 复制对象，并从函数返回这个对象

```cpp
classname (const classname &obj) {
   // 构造函数的主体
}
```

## 1.3. 友元函数

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

`friend void printWidth( Box box );`，`friend class ClassTwo;`

定义在类外部，但有权访问类的所有私有成员和保护成员。如果需要声明一个函数为类的友元函数，在定义该函数原型前使用关键字 **friend**。（在类内声明）

## 1.4. 内联函数

C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

## 1.5. 类内静态变量

可以通过外部使用类名+解析运算符 `::`调用和初始化，类的所有对象共享

# 2. 类的继承

继承方式：`public、protected、private`

```cpp
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```

# 3. 重载

## 3.1 运算符重载

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

`Box operator+(const Box&);`，

声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

`Box operator+(const Box&, const Box&);`

假如返回的是一个新的对象，所以在函数内实现功能的实现，需要新定义一个类，将其作为返回值

可重载的运算符

| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)                        |
| -------------- | ------------------------------------------------------------ |
| 关系运算符     | ==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于) |
| 逻辑运算符     | \|\|(逻辑或)，&&(逻辑与)，!(逻辑非)                          |
| 单目运算符     | + (正)，-(负)，*(指针)，&(取地址)                            |
| 自增自减运算符 | ++(自增)，--(自减)                                           |
| 位运算符       | \| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移) |
| 赋值运算符     | =, +=, -=, *=, /= , % = , &=, \|=, ^=, <<=, >>=              |
| 空间申请与释放 | new, delete, new[ ] , delete[]                               |
| 其他运算符     | **()**(函数调用)，**->**(成员访问)，**,**(逗号)，**[]**(下标) |

不可重载的运算符

- **`.`**：成员访问运算符
- **`.*`**, **`->*`**：成员指针访问运算符
- **`::`**：域运算符
- **`sizeof`**：长度运算符
- **`?:`**：条件运算符
- **`#`**： 预处理符号

## 3.2 函数重载

在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。

```cpp
void print(int i) {
    cout << "整数为: " << i << endl;
}

void print(double  f) {
    cout << "浮点数为: " << f << endl;
}

void print(char c[]) {
    cout << "字符串为: " << c << endl;
}
```

# 4. 多态

**静态多态**，通过继承实现。函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为函数在程序编译期间就已经设置好了。

**动态多态**，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

# 5. Virtual

## 5.1. 虚函数

虚函数源于c++中的类继承，是多态的一种。在c++中，一个基类的指针或者引用可以指向或者引用派生类的对象。同时，派生类可以重写基类中的成员函数。这里“重写”的要求是函数的特征标（包括参数的数目、类型和顺序）以及返回值都必须***与基类中的函数一致***。

可以在基类中将被重写的成员函数设置为虚函数，其含义是：当通过基类的指针或者引用调用该成员函数时，将根据指针指向的对象类型确定调用的函数，而非指针的类型。

1. 只需将基类中的成员函数声明为虚函数即可，派生类中重写的virtual函数自动成为虚函数；

2. 基类中的析构函数必须为虚函数，否则会出现对象释放错误。以上例说明，如果不将基类的析构函数声明为virtual，那么在调用delete p2;语句时将调用基类的析构函数，而不是应当调用的派生类的析构函数，从而出现对象释放错误的问题。

3. 虚函数的使用将导致类对象占用更大的内存空间。对这一点的解释涉及到虚函数调用的原理：编译器给每一个包括虚函数的对象添加了一个隐藏成员：指向虚函数表的指针。虚函数表（virtual function table）包含了虚函数的地址，由所有虚函数对象共享。当派生类重新定义虚函数时，则将该函数的地址添加到虚函数表中。无论一个类对象中定义了多少个虚函数，虚函数指针只有一个。相应地，每个对象在内存中的大小要比没有虚函数时大4个字节（32位主机，不包括虚析构函数）。如下：

    `cout<<sizeof(base)<<endl;             //12`
    `cout<<sizeof(inheriter)<<endl;          //12`

   base类中包括了两个整型的成员变量，各占4个字节大小，再加上一个虚函数指针，共计占12个字节；inheriter类继承了base类的两个成员变量以及虚函数表指针，因此大小与基类一致。如果inheriter多重继承自另外一个也包括了虚函数的基类，那么隐藏成员就包括了两个虚函数表指针。

4. 重写函数的特征标必须与基类函数一致，否则将覆盖基类函数；

5. 重写不同于重载。我对重载的理解是：同一个类，内部的同名函数具有不同的参数列表称为重载；重写则是派生类对基类同名函数的“本地改造”，要求函数特征标完全相同。当然，返回值类型不一定相同（可能会出现返回类型协变的特殊情况）。

## 5.2 虚基类

1. 若一个类多重继承自具有同一个基类的派生类时，调用同名成员函数时会出现二义性。为了解决这个问题，可以通过作用域解析运算符澄清，或者在类中进行重新定义；
2. 继承关系可能是非常繁复的。一个类可能多重继承自别的类，而它的父类也可能继承自别的类。当该类从不同的途径继承了两个或者更多的同名函数时，如果没有对类名限定为virtual，将导致二义性。当然，如果使用了虚基类，则不一定会导致二义性。编译器将选择继承路径上“最短”的父类成员函数加以调用。该规则与成员函数的访问控制权限并不矛盾。也就是说，不能因为具有更高调用优先级的成员函数的访问控制权限是"private"，而转而去调用public型的较低优先级的同名成员函数。

## 5.3 纯虚函数

若一个类的成员函数被声明为纯虚函数，则意味着该类是ABC(Abstract Base Class，抽象基类)，即只能被继承，而不能用来声明对象。纯虚函数通常需要在类声明的后面加上关键词“=0”。

`virtual void funtion1()=0`

当然，声明为纯虚函数并不意味着在实现文件中不可对其进行定义，只是意味着不可用抽象基类实现一个具体的对象。
