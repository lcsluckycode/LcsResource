# 装饰者模式

## 1. 基本介绍

装饰模式是为已有共嗯那个动态添加更多功能的一种方式。

当系统需要新动能的时候，是向旧的类中添加新的代码。这些代码通常装饰了原有类的核心职责或主要行为。

假如在主类中加入新的字段，新的方法或新的逻辑，会增加了主类的复杂度，但是装饰模式却提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，只有需要执行特殊行为的时候，可以在运行时有需要的选择和按顺序的使用装饰功能包装对象了。

## 2.结构图

![image-20220428155541406](E:\lcsprogram\study_doc\设计模式\image\装饰者模式结构图.png)

`Component`是定义一个对象接口，可以给这些对象动态的添加职责。

`ConcreteComponent`是定义一个具体对象，也可以给这个对象添加一些职责。

`Decorate`，装设抽象类，继承 `Component`，从外类来扩展 `Component` 类的功能，但对于 `Component` 来说，不需要知道它的存在

### 演示代码

 `component.h`

```cpp
#ifndef __COMPONENT_H
#define __COMPONENT_H
#include<iostream>
using namespace std;

class Component 
{
public:
    virtual void Operation() = 0;
};
#endif
```

`ConcreteComponent.h`

```cpp
#ifndef __CONCRETECOMPONENT_H
#define __CONCRETECOMPONENT_H
#include"Component.h"

class ConcreteComponent : public Component
{
public:
    void Operation() {
        cout << "具体操作对象" << endl;
    }
};
#endif
```

`Decorator.h`

```cpp
#ifndef __DECORATOR_H
#define __DECORATOR_H
#include"Component.h"

class Decorator : public Component
{
public:
    void setComponent(Component* component) {
        this->component = component;
    }
    void Operation() {
        if (component != nullptr) {
            component->Operation();
        }
    }
private:
    Component* component;
};
#endif
```

`test.cpp`

```cpp
#include"Decorator.h"
#include"ConcreteComponent.h"
#include<string>
using namespace std;

class ConcreteComponentA : public Decorator
{
public:
    void Operation() {
        Decorator::Operation();
        addedState = "new State";
        cout << addedState << endl;
    }
private:
    string addedState;
};

class ConcreteComponentB : public Decorator
{
public:
    void player() {
        cout << "B palyer" << endl;
    }
    void Operation() {
        Decorator::Operation();
        player();
        cout << "装饰对象B" << endl;
    }
};

int main() {
    ConcreteComponent* c = new ConcreteComponent();
    ConcreteComponentA* d1 = new ConcreteComponentA();
    ConcreteComponentB* d2 = new ConcreteComponentB();

    d1->setComponent(c);
    d2->setComponent(d1);
    d2->Operation();
    return 0;
}

/* 
具体操作对象
new State
B palyer
装饰对象B
*/
```

