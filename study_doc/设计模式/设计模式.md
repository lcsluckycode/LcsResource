# 设计模式

# UML类图

<img src="C:\Users\SDT16353\AppData\Roaming\Typora\typora-user-images\image-20220419092000913.png" alt="image-20220419092000913"  />

核心“系统中某部分改变不会影响其他部分”

**设计原则**

1. 封装变化
2. 多用组合，少用继承
3. 针对接口编程，而不是针对实现编程
4. 为交互对象之间的松耦合设计而努力
5. 对扩展开放，对修改关闭
6. 要依赖抽象，不要依赖具体类（依赖倒置原则）

# 观察者模式

**为交互对象之间的松耦合设计而努力**

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他所有的依赖者都会接收到通知并自动更新。

**要点**：

- 定义了对象之间一对多的关系
- 主题（也就是可观察者）用一个共同的接口来更新观察者
- 观察者与可观察者之间用松耦合方式结合，可观察者不知道观察者的细节，只知道观察者实现了观察者接口
- 使用观察者模式，可以从被观察者push数据或者pull数据
- 有多个观察者时，不可以依赖特定的通知顺序
- Java有多种观察者模式的实现，通用的java.util.Observeable
- Swing大量使用观察者模式

![image-20220222085901132](E:\lcsprogram\study_doc\设计模式\image\观察者模式.png)

![image-20220222091511535](E:\lcsprogram\study_doc\设计模式\image\观察站实例类图.png)

# 装饰者模式

**类应该对扩展开放，对修改关闭**

动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案

装饰者模式超类一般使用abstract类

**特点：**

- 装饰者与被装饰对象有相同的超类
- 可以用一个或者多个装饰者包装一个对象
- 既然装饰者和被装饰者对象具有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象替代它
- 对象可以在任何时候被装饰，所以可以在运行时动态地、不间断地用装饰者来装饰对象

![image-20220223164551640](E:\lcsprogram\study_doc\设计模式\image\装饰者模式.png)

# 工厂方法模式

**要依赖抽象，不要依赖具体类**（依赖倒置原则）

定义了一个创建对象的接口，但是由子类决定实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

![image-20220224090254465](E:\lcsprogram\study_doc\设计模式\image\工厂模式.png)

工厂模式都是用来封装对象的创建。通过让子类决定该创建对象是什么，来达到将对象创建的过程封装的目的。

创建者类

![image-20220224164612762](E:\lcsprogram\study_doc\设计模式\image\工厂模式创建者.png)

产品类

![image-20220224164646859](E:\lcsprogram\study_doc\设计模式\image\工厂模式产品类.png)

对于创建者类和产品类，它们类的层级是相同的。因为他们都有抽象类，而抽象类都有许多具体的子类，每一个子类都有自己特定的实现。

类图

![image-20220224165443964](E:\lcsprogram\study_doc\设计模式\image\工厂模式类图.png)

依赖倒置原则

- 变量不可以持有具体类的引用（如果使用new，就会持有具体类的引用。可以改用工厂来避开这样的做法）
- 不要让类派生自具体的类（如果派生自具体的类，就会依赖具体的类）
- 不要覆盖基类中已经实现的方法（如果基类已实现的方法，那么你的积累就不是真正适合被继承的抽象。基类中已经实现的方法，应该由所有子类共享）

