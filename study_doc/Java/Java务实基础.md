# Java务实基础

# 1. 数据类型

四类八种

- 整数型： 
  - byte（1字节，8位）
  - short（2字节，16位）
  - int（4字节，32位）
  - long（8字节，64位）
- 浮点型
  - float（单精度）32位
  - double（双精度）64位
- 字符型
  - char（4字节16位 `Unicode` 字符）

> 类名使用 `UpperCamelCase`的命名方法
>
> 方法名、参数名、成员变量、局部变量统一采用 `LowerCamelCase`
>
> 包名统一小写，点分隔符之间有且仅有一个自然语义的英语单词

**for-each**语句：（适用于数组、集合）

```java
int array[] = {7, 8, 9};

for (int arr : array) {
    System.out.println(arr);
}
```

# 2. 对象创建

```java
Car carKey;  //只是一个引用，而没有一个对象与之关联
Car carKey = new Car();  //新建一个对象与之关联
```

## 2.1 构造函数

没有 **参数类型** 和 **返回值**，名称与类名一致，且可以有多个。

如果手动定义了任何一个构造函数，**JVM就不在提供默认的构造函数，必须手动指定，不然会直接报错**。

## 2.2 方法重载

每个重载的方法都有独一无二的参数列表。包含参数的类型、顺序、参数数量等

重载的条件：

- 方法名必须相同
- 参数列表必须不同
- 方法的返回类型可以相同也可以不同
- 仅仅返回类型不同不足以成为方法的重载
- 重载发生在编译的时候

## 2.3 方法重写

子类与父类之间，子类重写父类的方法必须使用 `@Override`进行注解

## 2.4 创建对象

1. `new`

   1. 首先，当我们`new`一个对象时，比如`Sheep sheep = new Sheep()`，`JVM`首先就回去检查`Sheep`这个符号引用所代表的类是否已经被加载过，如果没有就要执行对应类的加载过程；
   2. 声明类型引用很简单，比如`Sheep sheep = new Sheep()`就会声明一个`Sheep`类型的引用`sheep`；
   3. 第一步类加载完成以后，对象所需的内存大小其实就已经确定下来了，接下来`JVM`就会在堆上为对象分配内存；
   4. 所谓的属性“`0`”值初始化非常好理解，即为实例化对象的各个属性赋上默认初始化“0”值，比如int的初始化0值就是0，而一个对象的初始化0值就是null；
   5. 接下来JVM会进行对象头的设置，这里面就主要包括对象的运行时数据（比如Hash码、分代年龄、锁状态标志、锁指针、偏向线程ID、偏向时间戳等）以及类型指针（JVM通过该类型指针来确定该对象是哪个类的实例）；
   6. 属性的显示初始化也好理解，比如定义一个类的时候，针对某个属性字段手动的赋值，如：`private String name = "codesheep";` 就在这时候给初始化上；
   7. 最后是调用类的构造方法来进行进行构造方法内描述的初始化动作。

2. 反射一个对象

   一般拿到 `class` 对象的方式有三种

   1. `类名.class`
   2. `对象名.getClass()`
   3. `Class.forName(全限定类名)`

   有了`Class`对象之后，接下来就可以调用其`newInstance()`方法来创建一个对象，就像这样：

   ```java
   Sheep sheep3 = (Sheep) Class.forName( "cn.codesheep.article.obj.Sheep" ).newInstance();
   Sheep sheep4 = Sheep.class.newInstance();
   ```

初始话顺序：

静态属性初始化 静态方法初始化 普通属性初始化 普通方法初始化 构造函数初始化

# 3. 访问控制权限

**public，protected，default，private**

![image-20220119201137122](E:\lcsprogram\study_doc\Java\images\访问权限.png)

## 3.1 继承（is - a）

**extends**

一个类最多只能继承一个父类，但是可以继承多个接口（）

**多态**

多态实现的三种充要条件

- 继承
- 重写父类方法
- 父类引用指向子类对象

## 3.2 组合（has - a）

组合是指在一个类内引用其他类

## 3.3 代理

代理的大致描述，A想要调用B类的方法，A类不直接调用，A在自己的类中创建一个B的对象代理，在由代理调用B的方法

## 3.4 static

静态可以用来修饰成员变量和方法，在整个应用程序执行期间都有效。

静态方法能够使用**类名.方法**直接调用。静态方法中没有this关键字。在静态方法中不能访问类的**非静态成员变量**和**非静态方法**，static可以修饰静态代码块，类似于类的初始化操作，由于静态模块随着类的加载而执行，因此，很多时候会将只需要进行一次初始化操作放在static代码块中运行。

**final** 可以修饰类、属性和方法

- final 修饰类时，表明该类不能被继承。final类的成员变量可以根据需要设为final，但是要注意final 类中所有的成员方法都会被隐式的指定为final方法
- final修饰方法的时候，表明该方法不能被任何子类重写。
- final修饰变量分两种情况，一种修饰基本变量类型表示数据类型不能被修改；一种是修饰引用类型，表示对其初始化之后便不能再指向另一个对象

# 4. 接口和抽象集

## 4.1 接口

`interface` 

- 接口是一个完全抽象的类，不会提供任何方法的实现，只会进行方法的定义

- 接口只能有两种访问修饰符，一种是 `public` ，对整个项目可见；另一种是 `default` 缺省值，只具有包访问权

- 接口只提供方法的定义，接口没有实现，但是接口可以被其他类实现。实现接口可以使用 `implements`关键字。

  ```java
  class Demo implements DemoImp {
      @Override
      public void writeWell() {
          System.out.println("Write Well.");
      }
  }
  ```

## 4.2 抽象类

`abstract`

抽象类能力弱于接口

- 如果一个类有抽象方法，那么这个类就是抽象类。使用关键字 `abstract` 修饰的方法一定是抽象方法。
- 抽象类可以有具体的方法。
- 抽象类的约束不像接口那么严格，可以在抽象类中定义 **构造方法、抽象方法、普通属性、方法、静态方法、静态属性**
- 抽象类和接口一样不能被实例化

# 5. 异常处理



![image-20220124104840291](E:\lcsprogram\study_doc\Java\images\java基础类的关系图.png)