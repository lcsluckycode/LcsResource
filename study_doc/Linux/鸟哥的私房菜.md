# 鸟哥的私房菜
## 1. 文件系统

### EXT2文件系统

限制：原则上ext2文件系统的block的大小与数量在格式化完成的时候就不再改变了，每一个block上只能存放一个文件的数据，如果文件大于block的大小，则一个文件会占用多个block数量，假如文件大小小于block，则该block剩余容量就不能再被使用了。



### 文件属性
使用`ls -l`查看文件列表的时候，各项代表的意义
`[权限][链接][拥有者][群组][文件大小][修改时间][文件名]`
[权限]这一栏第一个字符代表文件的属性
- [d]，目录
- [-]，文件
  - 纯文本文件、二进制文件、数据格式文件
- [l]，链接文件
- [b]，设备文件里面可供存储的周边设备（可随机存取设备）
- [c]，设备文件里面的序列列埠设备，例如键盘、鼠标（一次性读取设备）
### 文件属性与权限
- `chgrp`，改变文件所属群组

  - `chgrp group [-R] filename`

- `chown`，改变文件拥有者
  
  - `chown [-R] user[:group] filename`
  
- `chmod`，改变文件的权限，SUID，SGID，SBIT等等的属性
  - `r:4 > w:2 > x:1`
  - `chmod u=rwx,go=rx filename`

- `umask [022]`查看或者修改创建文件的时候的默认权限，值得注意的是，这个权限是对应减去的值

- `chattr [+-=][ASacdistu] filename` 设置文件隐藏属性

  > `A` ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改， 可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）
  >
  > `S` ：一般文件是非同步写入磁盘的，如果加上 S 这个属性时， 当你进行任何文件的修改，该更动会“同步”写入磁盘中。 
  >
  > `a` ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性
  >
  > `c` ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩， 但是在储存的时候，将会先进行压缩后再储存（看来对于大文件似乎蛮有用的！）
  >
  > `d` ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份 
  >
  > `i` ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！” 对于系统安全性有相当大的助益！只有 root 能设置此属性 s ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间， 所以如果误删了，完全无法救回来了喔！ 
  >
  > `u` ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中， 可以使用来救援该文件喔！

- `lsattr` 查看文件的隐藏属性

- 文件的特殊属性（设置的时候，值位于第一位，后三位是普通权限）

  - `SUID`仅对二进制程序有效，并是执行者短暂拥有该程序拥有者的权限 `4`
  - `SGID` 与上一个属性对应，这个属性作用于组 `2`
  - `SBIT` 只对目录有效，当使用者在具有该权限的目录下创建文件或者目录的时候，仅有自己与root用户可删除 `1`


|                            |          可分享的          |     不可分享的      |
| :------------------------: | :------------------------: | :-----------------: |
|           不变的           |      /usr(软件放置处)      |  /etc（配置文件）   |
|   /opt (第三方协力软件)    |    /boot (开机与核心档)    |                     |
|          可变动的          | /var/mail (使用者邮件信箱) | /var/run (程序相关) |
| /var/spool/news (新闻群组) |    /var/lock (程序相关)    |                     |

### 文件系统的简单操作

- 查看磁盘与目录的容量
  - `du [-ahskm]`  ：评估文件系统的磁盘使用量（常用在推估目录所占容量），会直接到文件系统去搜索所有文件
  - `df [-ahikHTm] filename` ：列出文件系统的整体磁盘使用量

- 实体链接与符号链接
  - Hard Link （hard link只在某个目录下新增一笔文件名链接到某个inode号码的关联记录），不能跨文件系统，不能link目录
    - `ln /etc/crontab .`
  - Symbolic Link（创建一个独立的文件）
    - `ln -s /etc/crontab crontab2`

- 磁盘分区与格式化（MBR，GPT）

  - 查看磁盘信息
    - `lsblk [-dfimpt] [device]` 列出所有设备
    - `blkid` 列出设备的UUID等参数
    - `parted device_name print` 列出磁盘分区表类型与分区信息
  - 磁盘分区
    - `gidsk` 只能在GPT分区表使用，`gidsk device_name`
    - `fdisk` 只能在MBR分区表使用，`fsisk device_name`
    - `partprobe` 更新Linux核心分区表信息
  - 格式化
    - `make filesystem`
    - `mkfs`
  - 文件系统检验
    - `xfs_repair [-fnd] decive_name` 只检查xfs文件系统
    - `fsck.ext4 [-pf] [-b superblock] divece_name`处理EXT4文件系统

- 文件系统挂载与卸载

  - 假如挂载的目录不为空，那么原目录的内容会被隐藏而不是覆盖
  - `mount -a ` 按照配置文件[/etc/fstab]，将所有未挂载的数据挂载到磁盘
  - `mount umount`
  - 开机挂载，到 `/etc/fstab`

- 特色设备loop挂载

  - ```bash
    mkdir /data/centos_dvd
    mount -o loop /tmp/CentOS-7.x.ios
    ```

  - dd创建空的大文件

    ```bash
    dd if=/dev/zero of=output_dir bs=1M count=512
    ```

    需要格式化才能用作一个独立的挂载空间

- 简单总结概要

> 一个可以被挂载的数据通常称为“文件系统, filesystem”而不是分区 （partition） 喔！
>
> 基本上 Linux 的传统文件系统为 Ext2 ，该文件系统内的信息主要有：
> -  superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余 量， 以及文件系统的格式与相关信息等； 
> - inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码；
> -  block：实际记录文件的内容，若文件太大时，会占用多个 block 。 
>
> Ext2 文件系统的数据存取为索引式文件系统（indexed allocation） 
>
> 需要磁盘重组的原因就是文件写入的 block 太过于离散了，此时文件读取的性能将会变的 很差所致。
>
> 这个时候可以通过磁盘重组将同一个文件所属的 blocks 汇整在一起。 
>
> Ext2文件系统主要有：boot sector, superblock, inode bitmap, block bitmap, inode table, data block 等六大部分。
>
> data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已 inode 记录文件的属性/权限等数据，其他重要项目为： 每个 inode 大小均为固定，有 128/256Bytes 两种基本容量。每个文件都仅会占用一个 inode 而已； 因此文件系统能够 创建的文件数量与 inode 的数量有关； 
>
> 文件的 block 在记录文件的实际数据，目录的 block 则在记录该目录下面文件名与其 inode 号码的对照表； 
>
> 日志式文件系统 （journal） 会多出一块记录区，随时记载文件系统的主要活动，可加快 系统复原时间；
>
> Linux 文件系统为增加性能，会让内存作为大量的磁盘高速缓存；
>
> 实体链接只是多了一个文件名对该 inode 号码的链接而已；
>
> 符号链接就类似Windows的捷径功能。 磁盘的使用必需要经过：
>
> 分区、格式化与挂载，分别惯用的指令为：gdisk, mkfs, mount 三个指令 分区时，
>
> 应使用 parted 检查分区表格式，再判断使用 fdisk/gdisk 来分区，或直接使用 parted 分区 
>
> 为了考虑性能，XFS 文件系统格式化时，可以考虑加上 agcount/su/sw/extsize 等参数较佳 
>
> 如果磁盘已无未分区的容量，可以考虑使用大型文件取代磁盘设备的处理方式，通过 dd 与格式化功能。
>
> 开机自动挂载可参考/etc/fstab之设置，设置完毕务必使用 mount -a 测试语法正确否；

## 2. 文件于文件系统的压缩，打包于备份

### 2.1 linux 常见的压缩指令

> ```
> *.Z compress 程序压缩的文件；
> *.zip zip 程序压缩的文件；
> *.gz gzip 程序压缩的文件；
> *.bz2 bzip2 程序压缩的文件；
> *.xz xz 程序压缩的文件；
> *.tar tar 程序打包的数据，并没有压缩过；
> *.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩
> *.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩
> *.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩
> ```

- `gzip [-cdtv#] filename` 压缩文件

  - `zcat/zmore/zless filename.gz` 读取压缩文件

- `bzip2 [-cdkzv#] filename` (k为保留原始文件)

  - `bzcat\bzmore\bzless filename.bz2`

- `xz [-dtlkc#] filename`

  - `xcat\xmore\xless filename.xz`

- 打包命令 `tat`，主要是由于压缩

  ```shell
  压 缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
  查 询：tar -jtv -f filename.tar.bz2
  解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录
  ```

  [-z|-j|-J]分别代表gzip，bzip2

**XFS文件系统备份**

`xfsdump` 只能备份XFS文件系统，使用xfsrestore解析

```bash
xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份数据
-L ：xfsdump 会纪录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明
-M ：xfsdump 可以纪录储存媒体的标头，这里可以填写此媒体的简易说明
-l ：是 L 的小写，就是指定等级～有 0~9 共 10 个等级喔！ （默认为 0，即完整备份）
-f ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 设备文件名或其他一般文件文件名等
-I ：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态
```

`xfsrestore`

```bash
xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录 &lt;==单一文件全系统复原
xfsrestore [-f 备份文件] -r 待复原目录 &lt;==通过累积备份文件来复原系统
xfsrestore [-f 备份文件] -i 待复原目录 &lt;==进入互动模式
-I ：跟 xfsdump 相同的输出！可查询备份数据，包括 Label 名称与备份时间等
-f ：后面接的就是备份文件！企业界很有可能会接 /dev/st0 等磁带机！我们这里接文件名！
-L ：就是 Session 的 Label name 喔！可用 -I 查询到的数据，在这个选项后输入！
-s ：需要接某特定目录，亦即仅复原某一个文件或目录之意！
-r ：如果是用文件来储存备份数据，那这个就不需要使用。如果是一个磁带内有多个文件，
需要这东西来达成累积复原
-i ：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！
```

**光盘**

## 查找命令

- `find [path] [option] [action] [-exec commond {} \;]` 

- `grep [-A] [-B] [--color=auto] 'str' filename`

**忽视的小命令**

- `rmdir`删除一个空的目录
- `ls -d`列出目录而不是全部文件
- 读取文件
  - `nl`读取文件并显示行号
  - `od`以二进制的方式读取文件内容
  - `cat` `-n`输出行号
  - `more` `less` 都能搜索，`vim`搜说类似

## 正则表达式

### 特色符号

|  特殊符号  | 代表意义                                                     |
| :--------: | ------------------------------------------------------------ |
| [:alnum:]  | 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z                 |
| [:alpha:]  | 代表任何英文大小写字符，亦即 A-Z, a-z                        |
| [:blank:]  | 代表空白键与 [Tab] 按键两者                                  |
| [:cntrl:]  | 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等     |
| [:digit:]  | 代表数字而已，亦即 0-                                        |
| [:graph:]  | 除了空白字符 （空白键与 [Tab] 按键） 外的其他所有按键        |
| [:lower:]  | 代表小写字符，亦即 a-z                                       |
| [:print:]  | 代表任何可以被打印出来的字符                                 |
| [:punct:]  | 代表标点符号 （punctuation symbol），亦即：" ' ? ! ; : # $... |
| [:upper:]  | 代表大写字符，亦即 A-Z                                       |
| [:space:]  | 任何会产生空白的字符，包括空白键, [Tab], CR 等等             |
| [:xdigit:] | 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符 |

- `^`首行 `$`尾行
- `.` 任意一个字符，`*` 重复前一个字符，任意次数
- 限定连续RE字符范围`{}`
- `+`重复"一个或一个以上"前一个re字符
- `?`零个或一个前一个re字符
- `|`or
- `()` 群组
- `()+`多个群组

### sed工具（可直接修改文件内容）

`sed [-nefr] [动作]`

```shell
-n ：使用安静（silent）模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。
但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行（或者动作）才会被列出来。
-e ：直接在命令行界面上进行 sed 的动作编辑；
-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作；
-r ：sed 的动作支持的是延伸型正则表达式的语法。（默认是基础正则表达式语法）
-i ：直接修改读取的文件内容，而不是由屏幕输出。

动作说明： [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表“选择进行动作的行数”，举例来说，如果我的动作
是需要在 10 到 20 行之间进行的，则“ 10,20[动作行为] ”
function 有下面这些咚咚：
a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）～
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现（目前的上一行）；
p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！
例如 1,20s/old/new/g 就是啦！
```

### awk数据处理工具

`awk '条件类型1{动作1} 条件类型2{动作2} ...' filename`

**diff**文件对比

`diff [-bBi] from-file to-file`
