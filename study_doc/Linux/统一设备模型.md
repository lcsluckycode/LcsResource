#  统一设备模型

## 基本概念

![device_toplogy](E:\lcsprogram\study_doc\Linux\images\设备模型.gif)

四个重要的概念：Bus，Class，Device和Driver

- Bus（总线）：总线是CPU和一个或者多个设备之间信息交互的通道。为了方便设备模型的抽象，所有的设备都应该挂载到总线上
- Class（分类）：在Linux设备模型中，Class的概念非常类似面向对象的class。它主要是集合具有相似功能或属性的设备。抽象出一头可以在多个设备之间共用的数据结构和接口。
- Device（设备）：抽象系统中所有的硬件设备，描述它的名字、属性、从属的Class等信息
- Driver（驱动）：Linux设备模型用Driver抽象硬件设备驱动程序，它包含设备初始化、电源管理相关的接口实现。

### Kobject

Kobject的核心功能是：保持一个引用计数，当该计数减为0时，自动释放（由本文所讲的kobject模块负责） Kobject所占用的meomry空间。这就决定了Kobject必须是动态分配的（只有这样才能动态释放）。

而Kobject大多数的使用场景，是内嵌在大型的数据结构中（如Kset、device_driver等），因此这些大型的数据结构，也必须是动态分配、动态释放的。那么释放的时机是什么呢？是内嵌的Kobject释放时。但是Kobject的释放是由Kobject模块自动完成的（在引用计数为0时），那么怎么一并释放包含自己的大型数据结构呢？

这时Ktype就派上用场了。我们知道，Ktype中的release回调函数负责释放Kobject（甚至是包含Kobject的数据结构）的内存空间，那么Ktype及其内部函数，是由谁实现呢？是由上层数据结构所在的模块！因为只有它，才清楚Kobject嵌在哪个数据结构中，并通过Kobject指针以及自身的数据结构类型，找到需要释放的上层数据结构的指针，然后释放它。

讲到这里，就清晰多了。所以，每一个内嵌Kobject的数据结构，例如kset、device、device_driver等等，都要实现一个Ktype，并定义其中的回调函数。同理，sysfs相关的操作也一样，必须经过ktype的中转，因为sysfs看到的是Kobject，而真正的文件操作的主体，是内嵌Kobject的上层数据结构！



顺便提一下，Kobject是面向对象的思想在Linux kernel中的极致体现，但C语言的优势却不在这里，所以Linux kernel需要用比较巧妙（也很啰嗦）的手段去实现，