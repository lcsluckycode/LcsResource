# 二叉树

## 平衡二叉树

判断条件

1. 二叉排序树（左节点小于根节点，右节点大于根节点）
2. 任何一个节点的左节点或者右节点都是平衡二叉树（左右高度差小于等于1）

### 相关概念

**平衡因子**（BF）

左子树和右子树高度差（表示：左子树高度 - 右子树高度）

一般BF的绝对值大于1，平衡二叉树就失衡，需要旋转纠正

**最小不平衡子树**

距离插入节点最近的，并且BF的绝对值大于1的节点为根节点的子树

![image-20220420161256997](E:\lcsprogram\study_doc\algorithm\image\最小不平衡子树.png)

### 两种旋转方式

1. 左旋
   1. 旧节点为新根节点的左子树
   2. 新根节点的左子树（如果存在）为旧节点的右子树
2. 右旋
   1. 旧根节点为新根节点的右子树
   2. 新根节点的右子树（如果存在）为旧根节点的左子树

**纠正类型**

1. LL型：插入左孩子的左子树，右旋
2. RR型：插入右孩子的右子树，左旋
3. LR型：插入左孩子的右子树，先左旋，再右旋
4. RL型：插入右孩子的右子树，先右旋，再左旋

![image-20220420161942725](E:\lcsprogram\study_doc\algorithm\image\纠正类型.png)

左旋：

```c++
AVLNode* leftRotate(AVLNode* root) {
    AVLNode* oldRoot = root;
    AVLNode* newRoot = root->right;
    AVLNode* parent = root->parent;

    //1.newRoot 替换 oldRoot 位置
    if (parent != nullptr) {
        if (oldRoot->parent->data > oldRoot->data) {
            parent->left = newRoot;
        }
        else {
            parent->right = newRoot;
        }
    }
    newRoot->parent = parent;
    //2.重新组装 oldRoot (将 newRoot 的左子树给 oldRoot 的右子树)
    oldRoot->right = newRoot->left;
    if (newRoot->left != nullptr) {
        newRoot->left->parent = oldRoot;
    }
    //3. oldRoot 为 newRoot 的左子树
    newRoot->left = oldRoot;
    oldRoot->parent = newRoot;

    //4. 刷新高度
    oldRoot->height = caculateHeight(oldRoot);
    newRoot->height = caculateHeight(newRoot);
    return newRoot;
}
```

右旋：

```c++
AVLNode* rightRotate(AVLNode* root) {
    AVLNode* oldRoot = root;
    AVLNode* newRoot = root->left;
    AVLNode* parent = root->parent;

    //1.newRoot 替换 oldRoot 位置
    if (parent != nullptr) {
        if (oldRoot->parent->data > oldRoot->data) {
            parent->left = newRoot;
        } else {
            parent->right = newRoot;
        }
    }
    newRoot->parent = parent;
    
    //2.重新组装 oldRoot (将 newRoot 的右子树给 oldRoot 的左子树)
    oldRoot->left = newRoot->right;
    if (newRoot->right != nullptr) {
        newRoot->right->parent = oldRoot;
    }

    //3.oldRoot 为 newRoot 的右子树
    newRoot->right = oldRoot;
    oldRoot->parent = newRoot;
    
    //4.刷新高度
    oldRoot->height = caculateHeight(oldRoot);
    newRoot->height = caculateHeight(newRoot);
    return newRoot;
}
```

## 红黑树

![在这里插入图片描述](E:\lcsprogram\study_doc\algorithm\image\红黑树.jpg)

规则

1. 节点不是黑色就是红色
2. 根节点为黑色
3. 叶节点为黑色（叶子节点是指末梢的空节点）
4. 一个节点为红色，则其两个子节点必须为红色（根到叶子的所有路径，不可能存在两个连续的红色节点）
5. 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）

左旋右旋的规则于平衡二叉树的规则一致

